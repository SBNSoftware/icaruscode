////////////////////////////////////////////////////////////////////////
// Class:       SimTestPulseAna
// Module Type: analyzer
// File:        SimTestPulseAna_module.cc
//
// Generated at Tue May 23 13:08:14 2017 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/Hit.h"

#include "ParamHolder.h"
#include <TFile.h>
#include <TTree.h>

class SimTestPulseAna;

class SimTestPulseAna : public art::EDAnalyzer
{
public:
    explicit SimTestPulseAna(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    
    // Plugins should not be copied or assigned.
    SimTestPulseAna(SimTestPulseAna const &) = delete;
    SimTestPulseAna(SimTestPulseAna &&) = delete;
    SimTestPulseAna & operator = (SimTestPulseAna const &) = delete;
    SimTestPulseAna & operator = (SimTestPulseAna &&) = delete;
    
    // Required functions.
    void analyze(art::Event const & e) override;
    
    void beginJob() override;
    void endJob()   override;
    void compute_params(const std::vector<float>& wf,
                        float& mean, float& rms, float& min, float& max,
                        int& argmin, int& argmax);
    
    TTree* CreateTree(std::string name);
    TTree* CreateHitTree(std::string name);

private:
    TTree* _hit_tree;
    TTree* _wire_tree;
    TTree* _raw_digit_tree;
    TTree* _filtered_digit_tree;
    art::InputTag _hit_producer;
    art::InputTag _wire_producer;
    art::InputTag _raw_digit_producer;
    art::InputTag _filtered_digit_producer;
    size_t _num_samples;
    size_t _reco_tick_offset;
    bool _verbose;
    // TTree variables
    int _run, _subrun, _event;
    int _ch, _wire;
    int _argmax, _argmin;
    int _tick_offset;
    int _plane;
    int _signal_id;
    int _start_tick;
    std::vector<float> _wf;
    float _mean;
    float _std_dev;
    float _max;
    float _min;
    // Following are specific to hits
    float _peakTime;
    float _peakAmplitude;
    float _rms;
    float _summedADC;
    float _integral;
    float _chisquare;
    float _baseline;
};

void SimTestPulseAna::compute_params(const std::vector<float>& wf,
                                     float& mean, float& std_dev, float& min, float& max,
                                     int& argmin, int& argmax)
{
    mean = std_dev = 0;
    min = std::numeric_limits<float>::max();
    max = std::numeric_limits<float>::min();
    for(size_t idx=0; idx<wf.size(); ++idx)
    {
        auto const& v = wf[idx];
        if(v < min) { min = v; argmin=idx; }
        if(v > max) { max = v; argmax=idx; }
        mean += v;
    }
    mean /= (float)(wf.size());
    for(auto const& v : wf)
        std_dev += pow(v - mean,2);
    std_dev = sqrt(std_dev / (float)(wf.size()));
}


SimTestPulseAna::SimTestPulseAna(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
  , _wire_tree(nullptr)
  , _raw_digit_tree(nullptr)
  , _filtered_digit_tree(nullptr)
{
      _verbose                 = p.get<bool>         ("Verbose",false);
      _hit_producer            = p.get<art::InputTag>("HitProducer","");
      _wire_producer           = p.get<art::InputTag>("WireProducer","");
      _raw_digit_producer      = p.get<art::InputTag>("RawDigitProducer","");
      _filtered_digit_producer = p.get<art::InputTag>("FilteredDigitProducer","");
      _reco_tick_offset        = p.get<size_t>       ("RecoTickOffset",2400);
      _num_samples             = p.get<size_t>       ("NumSample",10);
    
      if(_num_samples<1)
      {
        std::cerr << "\033[93m[ERROR]\033[00m waveform size will be less than 1 tick ..." << std::endl;
        throw std::exception();
      }
}

TTree* SimTestPulseAna::CreateTree(std::string name)
{
    art::ServiceHandle<art::TFileService> tfs;
    
    TTree* tree = tfs->make<TTree>(name.c_str(),"");

    tree->Branch("run",&_run,"run/I");
    tree->Branch("subrun",&_subrun,"subrun/I");
    tree->Branch("event",&_event,"event/I");
    tree->Branch("ch",&_ch,"ch/I");
    tree->Branch("wire",&_wire,"wire/I");
    tree->Branch("plane",&_plane,"plane/I");
    tree->Branch("signal_id",&_signal_id,"signal_id/I");
    tree->Branch("start_tick",&_start_tick,"start_tick/I");
    tree->Branch("tick_offset",&_tick_offset,"tick_offset/I");
    tree->Branch("wf","std::vector<float>",&_wf);
    tree->Branch("mean",&_mean,"mean/F");
    tree->Branch("std",&_std_dev,"std/F");
    tree->Branch("min",&_min,"min/F");
    tree->Branch("max",&_max,"max/F");
    tree->Branch("argmax",&_argmax,"argmax/I");
    tree->Branch("argmin",&_argmin,"argmin/I");
    return tree;
}

TTree* SimTestPulseAna::CreateHitTree(std::string name)
{
    art::ServiceHandle<art::TFileService> tfs;
    
    TTree* tree = tfs->make<TTree>(name.c_str(),"");

    tree->Branch("run",&_run,"run/I");
    tree->Branch("subrun",&_subrun,"subrun/I");
    tree->Branch("event",&_event,"event/I");
    tree->Branch("ch",&_ch,"ch/I");
    tree->Branch("wire",&_wire,"wire/I");
    tree->Branch("plane",&_plane,"plane/I");
    tree->Branch("signal_id",&_signal_id,"signal_id/I");
    tree->Branch("peakTime",&_peakTime,"peakTime/F");
    tree->Branch("peakAmplitude",&_peakAmplitude,"peakAmplitude/F");
    tree->Branch("rms",&_rms,"rms/F");
    tree->Branch("summedADC",&_summedADC,"summedADC/F");
    tree->Branch("integral",&_integral,"integral/F");
    tree->Branch("chisquare",&_chisquare,"chisquare/F");
    tree->Branch("baseline",&_baseline,"baseline/F");

    return tree;
}

void SimTestPulseAna::beginJob()
{
    _hit_tree = ( _hit_producer.empty() ? nullptr : this->CreateHitTree(_hit_producer.label()));
    _wire_tree = ( _wire_producer.empty() ? nullptr : this->CreateTree(_wire_producer.label()));
    _raw_digit_tree = ( _raw_digit_producer.empty() ? nullptr : this->CreateTree(_raw_digit_producer.label()) );
    _filtered_digit_tree = ( _filtered_digit_producer.empty() ? nullptr : this->CreateTree(_filtered_digit_producer.label()+"_f") );
}

void SimTestPulseAna::endJob()
{
}

void SimTestPulseAna::analyze(art::Event const & e)
{
    art::ServiceHandle<geo::Geometry> geo;
    _run = e.id().run();
    _subrun = e.id().subRun();
    _event = e.id().event();
    
    auto const& hit_array = alternative::ParamHolder::get().TruthHitArray();

    for(auto const& hit : hit_array)
    {
        if(hit.tick < _reco_tick_offset) {
            if(_verbose)
                std::cout << "[IMBECILE!] Skipping truth charge deposition ID " << hit.signal_id << " @ tick " << hit.tick << std::endl;
            continue;
        }

        _signal_id = hit.signal_id;
        
        //
        // RawDigit by daq
        //
        if(!_raw_digit_producer.empty()) {
            
            _tick_offset = 0;
            art::Handle<std::vector<raw::RawDigit> > digit_h;
            e.getByLabel(_raw_digit_producer,digit_h);
            if(!digit_h.isValid()) std::cerr << "[IMBECILE!] Failed to fetch RawDigit with label " << _raw_digit_producer << std::endl;
            
            for(auto const& ch : hit.channel_list) {
                _ch = ch;
                auto const wid = geo->ChannelToWire(ch).front();
                _wire = (int)(wid.Wire);
                _plane = wid.Plane;
                bool found=false;
                for(auto const& digit : *digit_h) {
                    if((int)(digit.Channel()) != ch) continue;
                    
                    auto const& adcs = digit.ADCs();
                    size_t start = (hit.tick > _num_samples ? hit.tick - _num_samples : 0);
                    size_t end = (adcs.size() > (hit.tick + _num_samples + 1) ? (hit.tick + _num_samples + 1) : adcs.size() -1);
                    _start_tick = start;
                    _wf.resize(end-start+1);
                    for(size_t index=start; index<=end; ++index) _wf[index-start] = adcs[index];
                    this->compute_params(_wf, _mean, _std_dev, _min, _max, _argmin, _argmax);
                    
                    if(_verbose)
                        std::cout << "[IMBECILE!] Storing " << _raw_digit_producer << " raw::RawDigit ... ch=" << _ch
                        << " plane=" << _plane
                        << " wire=" << _wire
                        << " ... " << adcs.size() << " ADC samples start @ tick=" << _start_tick
                        << " ... mean=" << _mean
                        << " std=" << _std_dev
                        << " ... min=" << _min << " @ tick=" << _start_tick + _argmin
                        << " ... max=" << _max << " @ tick=" << _start_tick + _argmax
                        << std::endl;
                    
                    _raw_digit_tree->Fill();
                    found=true;
                    break;
                }
                if(!found) std::cout << "[IMBECILE!] Could not find target channel " << _ch
                    << " or wire " << _wire
                    << " for producer " << _raw_digit_producer << std::endl;
            }
        }
        
        //
        // RawDigit by noise filter
        //
        if(!_filtered_digit_producer.empty()) {
            
            _tick_offset = _reco_tick_offset;
            int signal_tick = hit.tick - _tick_offset;
            
            art::Handle<std::vector<raw::RawDigit> > digit_h;
            e.getByLabel(_filtered_digit_producer,digit_h);
            if(!digit_h.isValid()) std::cerr << "[IMBECILE!] Failed to fetch RawDigit with label " << _filtered_digit_producer << std::endl;
            
            for(auto const& ch : hit.channel_list) {
                _ch = ch;
                auto const wid = geo->ChannelToWire(ch).front();
                _wire = wid.Wire;
                _plane = wid.Plane;
                bool found=false;
                for(auto const& digit : *digit_h) {
                    if((int)(digit.Channel()) != ch) continue;
                    
                    auto const& adcs = digit.ADCs();
                    size_t start = ( signal_tick > (int)(_num_samples) ? signal_tick - _num_samples : 0);
                    size_t end = (adcs.size() > (signal_tick + _num_samples + 1) ? (signal_tick + _num_samples + 1) : adcs.size() -1);
                    _wf.resize(end-start+1);
                    _start_tick = start;
                    for(size_t index=start; index<=end; ++index) _wf[index-start] = adcs[index];
                    this->compute_params(_wf, _mean, _std_dev, _min, _max, _argmin, _argmax);
                    
                    if(_verbose)
                        std::cout << "[IMBECILE!] Storing " << _filtered_digit_producer << " raw::RawDigit ... ch=" << _ch
                        << " plane=" << _plane
                        << " wire=" << _wire
                        << " ... " << adcs.size() << " ADC samples start @ tick=" << _start_tick
                        << " ... mean=" << _mean
                        << " std=" << _std_dev
                        << " ... min=" << _min << " @ tick=" << _start_tick + _argmin
                        << " ... max=" << _max << " @ tick=" << _start_tick + _argmax
                        << std::endl;
                    
                    _filtered_digit_tree->Fill();
                    found=true;
                    break;
                }
                if(!found) std::cout << "[IMBECILE!] Could not find target channel " << _ch
                    << " or wire " << _wire
                    << " for producer " << _filtered_digit_producer << std::endl;
            }
        }
        
        //
        // Wire
        //
        if(!_wire_producer.empty())
        {
            _tick_offset = _reco_tick_offset;
            int signal_tick = hit.tick - _tick_offset;
            
            art::Handle<std::vector<recob::Wire> > wire_h;
            e.getByLabel(_wire_producer,wire_h);
            if(!wire_h.isValid()) std::cerr << "[IMBECILE!] Failed to fetch Wire with label " << _wire_producer << std::endl;
            
            for(auto const& ch : hit.channel_list)
            {
                _ch = ch;
                auto const wid = geo->ChannelToWire(ch).front();
                _wire = wid.Wire;
                _plane = wid.Plane;
                bool found=false;
                for(auto const& wire : *wire_h)
                {
                    if((int)(wire.Channel()) != ch) continue;
                    
                    auto const& signalROI = wire.SignalROI();
                    
                    for(const auto& range : signalROI.get_ranges())
                    {
                        // check if this range is relevant
                        if(signal_tick < (int)(range.begin_index()) || signal_tick > (int)(range.begin_index() + range.data().size()))
                            continue;
                        
                        _wf.clear();
                        _wf.reserve(range.data().size());
                        for(auto const& v : range.data()) _wf.push_back(v);
                        _start_tick = range.begin_index();
                        this->compute_params(_wf, _mean, _std_dev, _min, _max, _argmin, _argmax);
                        
                        if(_verbose)
                            std::cout << "[IMBECILE!] Storing " << _wire_producer << " recob::Wire ... ch=" << _ch
                            << " plane=" << _plane
                            << " wire=" << _wire
                            << " ... " << range.data().size() << " ADC samples start @ tick=" << _start_tick
                            << " ... mean=" << _mean
                            << " std=" << _std_dev
                            << " ... min=" << _min << " @ tick=" << _start_tick + _argmin
                            << " ... max=" << _max << " @ tick=" << _start_tick + _argmax
                            << std::endl;
                        
                        _wire_tree->Fill();
                        found=true;
                        break;
                    }
                    break;
                }
                if(!found) std::cout << "[IMBECILE!] Could not find target channel " << _ch
                    << " or wire " << _wire
                    << " for producer " << _wire_producer << std::endl;
            }
        }
        
        // Recover hits
        if(!_hit_producer.empty())
        {
            _tick_offset = _reco_tick_offset;
            int signal_tick = hit.tick - _tick_offset;
            
            art::Handle<std::vector<recob::Hit> > hit_h;
            e.getByLabel(_hit_producer,hit_h);
            if(!hit_h.isValid()) std::cerr << "[IMBECILE!] Failed to fetch Wire with label " << _hit_producer << std::endl;
            
            for(auto const& ch : hit.channel_list)
            {
                _ch = ch;
                auto const wid = geo->ChannelToWire(ch).front();
                _wire = wid.Wire;
                _plane = wid.Plane;
                bool found=false;
                
                float diffPeakTime(1000.);
                
                for(auto const& recoHit : *hit_h)
                {
                    // Look for hit to match channel
                    if((int)(recoHit.Channel()) != ch) continue;
                    
                    // Look for hit range to match tick range
                    if(signal_tick < (int)(recoHit.PeakTime() - 3.*recoHit.RMS()) || signal_tick > (int)(recoHit.PeakTime() + 3.*recoHit.RMS())) continue;
                    
                    if (std::abs(recoHit.PeakTime() - signal_tick) < diffPeakTime)
                    {
                        found = true;
                       
                        _peakTime      = recoHit.PeakTime();
                        _peakAmplitude = recoHit.PeakAmplitude();
                        _rms           = recoHit.RMS();
                        _summedADC     = recoHit.ROISummedADC();
                        _integral      = recoHit.Integral();
                        _chisquare     = recoHit.GoodnessOfFit();
                        _baseline      = _wf[recoHit.StartTick()-_start_tick];
                        
                        diffPeakTime   = std::abs(_peakTime - signal_tick);
                    }
                }

                if (found) _hit_tree->Fill();

                if(!found) std::cout << "[IMBECILE!] Could not find target channel " << _ch
                                     << " or wire " << _wire
                                     << " for producer " << _hit_producer << std::endl;
            }
        }
    }
    
    return;
}

DEFINE_ART_MODULE(SimTestPulseAna)
