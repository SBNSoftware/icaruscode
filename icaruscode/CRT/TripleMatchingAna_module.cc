////////////////////////////////////////////////////////////////////////
// Class:       TripleMatchingAna
// Plugin Type: analyzer (Unknown Unknown)
// File:        TripleMatchingAna_module.cc
//
// Generated by Francesco Poppi on May 02 2024
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
#include "larcore/CoreUtils/ServiceUtil.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/RecoBase/PFParticleMetadata.h"
#include "lardataobj/RecoBase/Slice.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"

// Data product includes
#include "icaruscode/CRT/CRTUtils/CRTBackTracker.h"
#include "icaruscode/CRT/CRTUtils/CRTCommonUtils.h"
#include "icaruscode/Decode/DataProducts/TriggerConfiguration.h"
#include "larcorealg/CoreUtils/enumerate.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "nusimdata/SimulationBase/MCGeneratorInfo.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "sbnobj/Common/CRT/CRTHit.hh"
#include "sbnobj/Common/CRT/CRTTrack.hh"
#include "sbnobj/Common/Trigger/ExtraTriggerInfo.h"
#include "sbnobj/Common/CRT/CRTPMTMatching.hh"

// C++ includes
#include <map>
#include <numeric>
#include <vector>
#include <optional>

// ROOT includes
#include "TTree.h"
#include "TVector3.h"
#include "TMatrixD.h"
#include "TMatrixDEigen.h"
#include "TGraph2D.h"
#include <Math/Vector3D.h>
#include <Fit/Fitter.h>
#include <Math/Functor.h>

#include "TMVA/DataLoader.h"
#include "TMVA/Factory.h"
#include "TMVA/TMVAGui.h"
#include "TMVA/Reader.h"
#include "TMVA/Tools.h"

using std::map;
using std::vector;

namespace icarus {
namespace crt {

class TripleMatchingAna;

}  // namespace crt
}  // namespace icarus

using namespace icarus::crt;

class icarus::crt::TripleMatchingAna : public art::EDAnalyzer {
 public:
  using CRTHit = sbn::crt::CRTHit;
  using CRTPMTMatching = sbn::crt::CRTPMTMatching;
  explicit TripleMatchingAna(fhicl::ParameterSet const& p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TripleMatchingAna(TripleMatchingAna const&) = delete;
  TripleMatchingAna(TripleMatchingAna&&) = delete;
  TripleMatchingAna& operator=(TripleMatchingAna const&) = delete;
  TripleMatchingAna& operator=(TripleMatchingAna&&) = delete;

  // Required functions.
  void beginRun(art::Run const& r) override;
  void analyze(art::Event const& e) override;

 private:
  // Declare member data here.

  void ClearVecs();
  void ClearVecsCRT();
  void ClearVecsCRTPMT();

  // art::InputTag fOpHitModuleLabel;
  art::InputTag fOpFlashModuleLabel0;
  art::InputTag fOpFlashModuleLabel1;
  art::InputTag fOpFlashModuleLabel2;
  art::InputTag fOpFlashModuleLabel3;
  art::InputTag fCrtHitModuleLabel;
  art::InputTag fTriggerLabel;
  art::InputTag fTriggerConfigurationLabel;
  art::InputTag fCrtPmtModuleLabel;
  // tart::InputTag fCrtTrackModuleLabel;
  std::vector<art::InputTag> fSliceLabel; ///< labels for source of Slices
  std::vector<art::InputTag> fTPCTrackLabel; ///< labels for source of tracks
  std::vector<art::InputTag> fPFParticleLabel; ///< labels for source of PFParticle
  std::vector<art::InputTag> fHitLabel; ///< labels for source of hits
  std::vector<art::InputTag> fTrackHMLabel; ///< labels for source of hits metadata
  
  //art::InputTag fTRKHMproducer; 
  
  std::optional<icarus::TriggerConfiguration> fTriggerConfiguration;

  int fEvent;   ///< number of the event being processed
  int fRun;     ///< number of the run being processed
  int fSubRun;  ///< number of the sub-run being processed

  double fTrackLength; ///< track length
  double fTrackStartX; ///< track startX
  double fTrackStartY; ///< track startY
  double fTrackStartZ; ///< track startZ
  double fTrackEndX; ///< track endX
  double fTrackEndY; ///< track endY
  double fTrackEndZ; ///< track endZ
  double fTrackScore; ///< track score
  double fNuScore; ///< nu score
  double fClearCosmic; ///< clear cosmic
  int fSizeHits; ///< nhits of the Tracks
  double fT0Track; ///< time of the Tracks
  double fDirStartx; ///< dirx of Start
  double fDirStarty; ///< diry of Start
  double fDirStartz; ///< dirz of Start
  double fDirEndx; ///< endx of Start
  double fDirEndy; ///< endy of Start
  double fDirEndz; ///< endz of Start
  double fDirXAvg;
  double fDirYAvg;
  double fDirZAvg;
  double fDirXPCA;
  double fDirYPCA;
  double fDirZPCA;
  std::vector<float> fTPx;
  std::vector<float> fTPy;
  std::vector<float> fTPz;
  std::vector<float> fDriftedx;
  std::vector<float> fDriftedy;
  std::vector<float> fDriftedz;
  std::vector<int> fPlane;
  std::vector<int> fTPC;
  double fFlashTime;
  int fOutBound;
  double fDriftstartX;
  double fDriftendX;
  double fLight_baryX;
  double fLight_baryY;
  double fLight_baryZ;
  double fCharge_baryX;
  double fCharge_baryY;
  double fCharge_baryZ;
  int fIDTrack;
  int fCryo;
  int fNMatch;
  float fDeltaZ;
  std::vector<float> fCRTx;
  std::vector<float> fCRTy;
  std::vector<float> fCRTz;
  int fFlashclassif;

  double fDeltaP;
  double fTrackRes;
  double fGoodhits;
  std::vector<double> fProjectedtpcdist;
  std::vector<int> fFeb_id; //Front end board id on the top CRT
  std::vector<std::vector<float>> fFeb_peshit; //photo electrons detected on each channel of the front end board
  std::vector<int> fPeshitover; //number of feb channels over 1.5 pe in the top CRT
  std::vector<float> fCRTXPANDORA;
  std::vector<float> fCRTZPANDORA;
  std::vector<float> fCRTXPCA;
  std::vector<float> fCRTZPCA;
  std::vector<float> fDeltaCRTXPANDORA;
  std::vector<float> fDeltaCRTZPANDORA;
  std::vector<float> fDeltaCRTXPCA;
  std::vector<float> fDeltaCRTZPCA;
  std::vector<float> fCrtdistancepandora;
  std::vector<float> fCrtdistancePCA;
  std::vector<int>   fCrtregion;
  std::vector<int>   fCrtsys;
  int fCrtmult;
  std::vector<Double_t> fMLPScore;
  std::vector<Double_t> fCRTPMTTimeDiff;
  std::vector<Double_t> fHiddenLength;
  

  // add trigger data product vars
  unsigned int m_gate_type;
  std::string m_gate_name;
  uint64_t m_trigger_timestamp;
  uint64_t m_gate_start_timestamp;
  uint64_t m_trigger_gate_diff;
  uint64_t m_gate_width;

  CRTCommonUtils* crtutil;
  std::vector<art::InputTag> fFlashLabels;
  TTree* fMatchTree;

  // matchTree vars

  geo::GeometryCore const* fGeometryService;  ///< pointer to Geometry provider
};

icarus::crt::TripleMatchingAna::TripleMatchingAna(fhicl::ParameterSet const& p)
    : EDAnalyzer{p}  // ,
      //,fOpHitModuleLabel(p.get<art::InputTag>("OpHitModuleLabel","ophit"))
      ,
      fOpFlashModuleLabel0(
          p.get<art::InputTag>("OpFlashModuleLabel0")),
      fOpFlashModuleLabel1(
          p.get<art::InputTag>("OpFlashModuleLabel1")),
      fCrtHitModuleLabel(p.get<art::InputTag>("CrtHitModuleLabel", "crthit")),
      fTriggerLabel(p.get<art::InputTag>("TriggerLabel", "daqTrigger")),
      fTriggerConfigurationLabel(
          p.get<art::InputTag>("TriggerConfiguration", "triggerconfig")),
      fCrtPmtModuleLabel(p.get<art::InputTag>("CrtPmtModuleLabel")),
      fSliceLabel(p.get< std::vector<art::InputTag> >("SliceLabel",             {""})),
      fTPCTrackLabel(p.get< std::vector<art::InputTag> >("TPCTrackLabel",             {""})),
      fPFParticleLabel(p.get< std::vector<art::InputTag> >("PFParticleLabel",             {""})),  
      fHitLabel(p.get< std::vector<art::InputTag> >("HitLabel",             {""})),
      fTrackHMLabel(p.get< std::vector<art::InputTag> >("TRKHMLabel",             {""})),
      
      //fTRKHMLabel(p.get< std::vector<art::InputTag> > ("TRKHMLabel", {""})),
      
      crtutil(new CRTCommonUtils())
// More initializers here.
{
  // Call appropriate consumes<>() for any products to be retrieved by this
  // module.
  fFlashLabels.push_back(fOpFlashModuleLabel0);
  fFlashLabels.push_back(fOpFlashModuleLabel1);

  // Get a pointer to the geometry service provider.
  fGeometryService = lar::providerFrom<geo::Geometry>();

  art::ServiceHandle<art::TFileService> tfs;

}


void icarus::crt::TripleMatchingAna::beginRun(art::Run const& r) {
  
  // we don't know if this is data or not; if not, there will be no trigger config
  auto const& trigConfHandle = 
    r.getHandle<icarus::TriggerConfiguration>(fTriggerConfigurationLabel);
  
  fTriggerConfiguration
    = trigConfHandle.isValid()? std::make_optional(*trigConfHandle): std::nullopt;

}


void icarus::crt::TripleMatchingAna::analyze(art::Event const& e) {
  // Implementation of required member function here.
  auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService const>()->DataFor(e);
  auto const detProp = art::ServiceHandle<detinfo::DetectorPropertiesService const>()->DataFor(e, clockData);
  if (!fTriggerConfiguration) {
    mf::LogDebug("TripleMatchingAna")
      << "Skipping because no data (or at least no trigger configuration).";
    return;
  }
  
  mf::LogDebug("TripleMatchingAna: ") << "beginning analyis" << '\n';
  // Start by fetching some basic event information for our n-tuple.
  fEvent = e.id().event();
  fRun = e.run();
  fSubRun = e.subRun();
  ClearVecs();
  ClearVecsCRT();
  ClearVecsCRTPMT();

  std::cout<<"Event: "<<fEvent<<" Run: "<<fRun<<" SubRun: "<<fSubRun<<std::endl;

  // OpFlash
  std::array<art::Handle<std::vector<recob::OpFlash>>, 2U> flashHandles;
  for (int i = 0; i < 2; i++) {
    flashHandles[i] = e.getHandle<std::vector<recob::OpFlash>>(fFlashLabels[i]);
  }

  // CRTHits
  std::vector<art::Ptr<CRTPMTMatching>> CRTPMTMatchingList;
  art::ValidHandle<std::vector<CRTPMTMatching>> crtpmtmatches = e.getValidHandle<std::vector<CRTPMTMatching>>(fCrtPmtModuleLabel);
  art::fill_ptr_vector(CRTPMTMatchingList, crtpmtmatches);
  art::FindManyP<recob::OpFlash> fmCRTPMTFlash(CRTPMTMatchingList, e, fCrtPmtModuleLabel);
  art::FindManyP<CRTHit> fmCRTHits(CRTPMTMatchingList, e, fCrtPmtModuleLabel);

  for(unsigned int i=0; i<CRTPMTMatchingList.size(); i++){
    const CRTPMTMatching &thisFlash = (*crtpmtmatches)[i];
    std::cout<<"Flash Time "<<thisFlash.flashTime<<" Flash Classification "<<(int)thisFlash.flashClassification<<" FlashPosition "<<thisFlash.flashPosition<<" SpreadY "<<thisFlash.flashYWidth<<" SpreadZ "<<thisFlash.flashZWidth<<std::endl;
  }

  for(const auto& [ SliceLabel, PFPLabel, TPCTrackLabel, HitLabel, HMLabel]: util::zip(fSliceLabel, fPFParticleLabel, fTPCTrackLabel, fHitLabel, fTrackHMLabel)){
    std::vector<art::Ptr<recob::PFParticle>> PFParticleList;
    art::ValidHandle<std::vector<recob::PFParticle>> pfparticles = e.getValidHandle<std::vector<recob::PFParticle>>(PFPLabel);
    art::fill_ptr_vector(PFParticleList, pfparticles);

    std::vector<art::Ptr<recob::Slice>> SliceList;
    art::ValidHandle<std::vector<recob::Slice>> slices = e.getValidHandle<std::vector<recob::Slice>>(SliceLabel);
    art::fill_ptr_vector(SliceList, slices);

    // Slice - associated data
    art::FindManyP<recob::PFParticle> fmPFPs(SliceList, e, PFPLabel);
    art::FindManyP<recob::Track> fmTracks(PFParticleList, e, TPCTrackLabel);

    art::ValidHandle<std::vector<recob::Track>> tracks = e.getValidHandle<std::vector<recob::Track>>(TPCTrackLabel);
    art::ValidHandle<std::vector<recob::Hit>> allhit_handle = e.getValidHandle<std::vector<recob::Hit>>(HitLabel);
    std::vector<art::Ptr<recob::Hit>> allHits;
    art::fill_ptr_vector(allHits, allhit_handle);

    int counter=0;
    
    for (art::Ptr<recob::Slice> const& p_slice: SliceList) {

      std::cout<<"Slice ID "<<p_slice->ID()<<" ; Center "<<p_slice->Center()<<" ; Charge "<<p_slice->Charge()<<std::endl;
      std::cout<<"Slice number "<<counter<<std::endl;

      const std::vector<art::Ptr<recob::PFParticle>> &pfpsVec = fmPFPs.at(p_slice.key());
      int nPFPs = pfpsVec.size();
      std::cout<<"Size of PFPs "<<nPFPs<<std::endl;

      for(art::Ptr<recob::PFParticle> const& p_pfp: pfpsVec){
        const std::vector<art::Ptr<recob::Track>> thisTrack = fmTracks.at(p_pfp.key());
        if (thisTrack.size() != 1) continue;    
        art::Ptr<recob::Track> trkPtr = thisTrack.at(0);
        const recob::Track &track = *trkPtr;
        std::cout<<"Track Length "<<track.Length()<<" Start "<<track.Start()<<" End "<<track.End()<<std::endl;

        art::InputTag thm_label = HMLabel;
        art::FindManyP<recob::Hit, recob::TrackHitMeta> fmtrkHits(tracks, e, thm_label);
        std::vector<art::Ptr<recob::Hit>> emptyHitVector;
        const std::vector<art::Ptr<recob::Hit>> &trkHits  = fmtrkHits.isValid() ? fmtrkHits.at(trkPtr.key()) : emptyHitVector;
        std::vector<const recob::TrackHitMeta*> emptyTHMVector;
        const std::vector<const recob::TrackHitMeta*> &trkHitMetas = fmtrkHits.isValid() ? fmtrkHits.data(trkPtr.key()) : emptyTHMVector;
      
        for(auto const& [trkHit, trkHitMeta]: util::zip(trkHits, trkHitMetas)){
          bool badhit = (trkHitMeta->Index() == std::numeric_limits<unsigned int>::max()) ||
                    (!track.HasValidPoint(trkHitMeta->Index()));
          if(badhit) continue;
          geo::Point_t loc = track.LocationAtPoint(trkHitMeta->Index());
          std::cout<<"Point "<<loc<<std::endl;
        }
      }

      counter++;
    }

  }
}


void icarus::crt::TripleMatchingAna::ClearVecs() {
  // matchTree


}
void icarus::crt::TripleMatchingAna::ClearVecsCRT() {
  // matchTree
 
}

void icarus::crt::TripleMatchingAna::ClearVecsCRTPMT() {
  // matchTree

}

DEFINE_ART_MODULE(icarus::crt::TripleMatchingAna)
